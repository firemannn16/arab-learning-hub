<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>–¢—Ä–µ–Ω–∞–∂–µ—Ä –≤—ã–±–æ—Ä–∞ - –ê—Ä–∞–±—Å–∫–∏–µ —Å–ª–æ–≤–∞</title>
    <script src="dua.js"></script>
    <script src="service-worker-register.js"></script>
    <script src="storage-protection.js"></script>
<script type="module">
/* ---------- Firebase –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ---------- */
const firebaseConfig = {
    apiKey: "AIzaSyCYm7d5ihMS9u0z_hq-1JG7TKrZvXzQZYk",
    authDomain: "–∞—Ä–∞–±—Å–∫–∏–π-e3be6.firebaseapp.com",
    databaseURL: "https://–∞—Ä–∞–±—Å–∫–∏–π-e3be6-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "–∞—Ä–∞–±—Å–∫–∏–π-e3be6",
    storageBucket: "–∞—Ä–∞–±—Å–∫–∏–π-e3be6.firebasestorage.app",
    messagingSenderId: "531088407371",
    appId: "1:531088407371:web:e1fd3e7e2cf33ee4f29c4a"
};
try {
  const { initializeApp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js');
  const { getFirestore } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
  window.firebaseApp = initializeApp(firebaseConfig);
  window.firestore = getFirestore(window.firebaseApp);
  window.firebaseEnabled = true;
  window.firebaseModules = { doc: null, setDoc: null, getDoc: null, deleteDoc: null };
  const firestoreModule = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js');
  window.firebaseModules.doc = firestoreModule.doc;
  window.firebaseModules.setDoc = firestoreModule.setDoc;
  window.firebaseModules.getDoc = firestoreModule.getDoc;
  window.firebaseModules.deleteDoc = firestoreModule.deleteDoc;
  console.log('Firebase –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω');
} catch(e) {
  console.warn('Firebase –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω:', e);
  window.firebaseEnabled = false;
}
</script>
<style>
  body{font-family:Arial,Helvetica,sans-serif;margin:18px;color:#111;background:#fff}
  #container{max-width:980px;margin:0 auto}
  .hidden{display:none}
  .button{padding:8px 12px;margin:6px;font-size:1rem;cursor:pointer;border-radius:6px;border:1px solid #bbb;background:#f6f6f6}
  .home-btn{display:inline-block;padding:10px 20px;margin-bottom:20px;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;text-decoration:none;border-radius:8px;font-weight:bold;transition:opacity .3s}
  .home-btn:hover{opacity:.9}
  h1{font-size:1.6rem;margin:6px 0}
  #progress{margin:12px 0;color:#333}
  #arabic-word{
    font-size:3rem;
    padding:18px 14px;
    background:#fff;
    border-radius:10px;
    border:1px solid #eee;
    text-align:center;
    direction:rtl;
    line-height:1.05;
    white-space:normal;
    word-break:break-word;
    min-height:3.6em;
    font-family: "Noto Naskh Arabic", "Arial", "Tahoma", "Segoe UI", system-ui, sans-serif;
  }
  #arabic-word.rus-mode{
    direction:ltr;
    font-family:Arial,Helvetica,sans-serif;
  }
  .choices{display:flex;flex-direction:column;gap:12px;margin-top:12px}
  .choice-btn{padding:14px;border-radius:10px;border:1px solid #e0e0e0;background:#fff;font-size:1.35rem;text-align:center;cursor:pointer}
  .choice-btn.arab-option{
    direction:rtl;
    font-family: "Noto Naskh Arabic", "Arial", "Tahoma", "Segoe UI", system-ui, sans-serif;
    font-size:1.89rem;
  }
  .choice-btn.correct{background:#d9f7e0;border-color:#8ad39f}
  .choice-btn.wrong{background:#ffdede;border-color:#ff8a8a}
  #lists{display:flex;gap:20px;margin-top:18px;flex-wrap:wrap}
  #correct-list,#mistake-list{flex:1 1 320px;min-height:80px;background:#fafafa;padding:10px;border-radius:6px;border:1px solid #eee;max-height:280px;overflow:auto}
  textarea{width:100%;height:120px;padding:8px;font-size:1rem}
  .small{font-size:0.95rem;color:#666}
  .overlay{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.38);display:flex;align-items:center;justify-content:center;z-index:10000;padding:20px}
  .modal{background:#fff;border-radius:8px;padding:22px;max-width:820px;width:100%;box-shadow:0 6px 30px rgba(0,0,0,0.25)}
  .modal h2{margin:0 0 8px;font-size:22px}
  .modal .answer{font-weight:700;font-size:20px;direction:rtl;text-align:right}
  
  /* –ü–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å —Ñ–æ—Ä–º–∞—Ç–∞ */
  .format-toggle{
    display:flex;
    align-items:center;
    justify-content:center;
    gap:10px;
    margin:12px 0;
    font-size:1rem;
  }
  .toggle-switch{
    position:relative;
    width:60px;
    height:30px;
    background:#ccc;
    border-radius:15px;
    cursor:pointer;
    transition:background 0.3s;
  }
  .toggle-switch.active{
    background:#4CAF50;
  }
  .toggle-slider{
    position:absolute;
    top:3px;
    left:3px;
    width:24px;
    height:24px;
    background:#fff;
    border-radius:50%;
    transition:left 0.3s;
  }
  .toggle-switch.active .toggle-slider{
    left:33px;
  }
  
  @media(max-width:560px){
    #arabic-word{font-size:2.2rem;padding:12px}
    .choice-btn{font-size:1.1rem;padding:12px}
    .choice-btn.arab-option{font-size:1.54rem;}
  }
</style>
</head>
<body>
  <div id="container">
    <a href="index.html" class="home-btn">‚Üê –í–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞ –≥–ª–∞–≤–Ω—É—é</a>
    <h1>–¢—Ä–µ–Ω–∞–∂—ë—Ä –≤—ã–±–æ—Ä–∞</h1>
    <div id="trainer" style="margin-top:14px">
      <div class="format-toggle">
        <span>–ê–†–ë ‚Üí –†–£–°</span>
        <div class="toggle-switch" id="format-toggle">
          <div class="toggle-slider"></div>
        </div>
        <span>–†–£–° ‚Üí –ê–†–ë</span>
      </div>
      <div id="progress">0/0 —Å–ª–æ–≤ –ø—Ä–æ–π–¥–µ–Ω–æ ‚Äì 0 –æ—à–∏–±–æ–∫</div>
      <div id="arabic-word" aria-live="polite"></div>
      <div class="choices" id="choices">
        <button class="choice-btn" id="opt0"></button>
        <button class="choice-btn" id="opt1"></button>
        <button class="choice-btn" id="opt2"></button>
      </div>
      <div style="margin-top:10px">
        <button id="add-new-btn" class="button">–î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–µ —Å–ª–æ–≤–∞</button>
        <button id="reset-progress-btn" class="button">–°–±—Ä–æ—Å–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å</button>
        <button id="copy-mistakes-btn" class="button">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –æ—à–∏–±–∫–∏</button>
      </div>
      <div id="lists">
        <div>
          <h3>–ü—Ä–∞–≤–∏–ª—å–Ω–æ:</h3>
          <div id="correct-list">‚Äî</div>
        </div>
        <div>
          <h3>–û—à–∏–±–∫–∏:</h3>
          <div id="mistake-list">‚Äî</div>
        </div>
      </div>
      <div id="after" class="hidden" style="margin-top:14px">
        <button id="retry-all" class="button">–ü—Ä–æ–π—Ç–∏ –∑–∞–Ω–æ–≤–æ</button>
        <button id="work-mistakes" class="button hidden">–†–∞–±–æ—Ç–∞ –Ω–∞–¥ –æ—à–∏–±–∫–∞–º–∏</button>
      </div>
    </div>
  </div>
  <div id="modal-root"></div>
<script>
/* ========== ‚úÖ –ò–î–ï–ù–¢–ò–§–ò–ö–ê–¢–û–† –¢–†–ï–ù–ê–ñ–ï–†–ê ========== */
const TRAINER_ID = 'choice';

/* ========== ‚úÖ –ü–†–ï–§–ò–ö–° –î–õ–Ø –≠–¢–û–ì–û –¢–†–ï–ù–ê–ñ–ï–†–ê ========== */
const PREFIX = 'choice_';

/* ========== ‚úÖ –û–ë–©–ò–ô –ö–û–î –î–õ–Ø –í–°–ï–• –¢–†–ï–ù–ê–ñ–ï–†–û–í ========== */
const SHARED_CODE_KEY = 'userProgressCode';

/* ========== –ö–æ–Ω—Ñ–∏–≥ ========== */
const AUTO_MODAL_CLOSE_MS = 17000;

/* ========== ‚úÖ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–¥–∞ ========== */
function generateCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = '';
  for (let i = 0; i < 6; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

function getUserCode() {
  let code = safeLocalStorageGet(SHARED_CODE_KEY);
  if (!code) {
    code = generateCode();
    safeLocalStorageSet(SHARED_CODE_KEY, code, false);
    console.log('üÜï –°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π –∫–æ–¥:', code);
  }
  return code;
}

const USER_CODE = getUserCode();

/* ========== –£—Ç–∏–ª–∏—Ç—ã ========== */
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* ========== –£–¥–∞–ª–µ–Ω–∏–µ –æ–≥–ª–∞—Å–æ–≤–æ–∫ ========== */
function stripHarakat(text) {
  return String(text || '').replace(/[\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED]/g, '');
}

/* ========== –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å–ª–æ–≤ –ø–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É ========== */
function getWordContentHash(wordObj) {
  const rusContent = (wordObj.rusVariants || []).join('|');
  const arabContent = wordObj.arabicFull;
  return `${rusContent}|||${arabContent}`;
}

/* ========== –°–æ—Å—Ç–æ—è–Ω–∏—è ========== */
let allWords = [];
let orderRaw = [];
let currentRaw = null;
let mistakes = [];
let corrects = [];
let mode = 'all';
let loadingPromise = null;
let direction = 'arab-to-rus'; // 'arab-to-rus' –∏–ª–∏ 'rus-to-arab'

/* ========== DOM ========== */
const trainer = document.getElementById('trainer');
const progressDiv = document.getElementById('progress');
const arabicWordDiv = document.getElementById('arabic-word');
const optButtons = [document.getElementById('opt0'), document.getElementById('opt1'), document.getElementById('opt2')];
const addNewBtn = document.getElementById('add-new-btn');
const resetProgressBtn = document.getElementById('reset-progress-btn');
const copyMistakesBtn = document.getElementById('copy-mistakes-btn');
const correctListDiv = document.getElementById('correct-list');
const mistakeListDiv = document.getElementById('mistake-list');
const afterDiv = document.getElementById('after');
const retryAllBtn = document.getElementById('retry-all');
const workMistakesBtn = document.getElementById('work-mistakes');
const modalRoot = document.getElementById('modal-root');
const formatToggle = document.getElementById('format-toggle');

/* ========== –ü–∞—Ä—Å–µ—Ä / –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è ========== */
function normalizeLine(line){
  if(!line) return '';
  line = line.replace(/^\uFEFF/, '');
  line = line.replace(/[\u2010\u2011\u2012\u2013\u2014\u2015‚Äì‚Äî‚àí]/g, '-');
  line = line.replace(/\u00A0/g,' ');
  line = line.replace(/\s+/g,' ').trim();
  return line;
}

function detectPOS(rusVars){
  const verbEndings = ['—Ç—å—Å—è','—Ç—å','–∏—Ç—å','–µ—Ç—å','–∞—Ç—å','–æ–≤–∞—Ç—å','–Ω—É—Ç—å','—è—Ç—å','—Ç–∏—Å—å','–∏—Å—å','–æ–≤–∞—Ç—å—Å—è','—Å—è'];
  for(const v of rusVars){
    const s = v.toLowerCase().trim();
    for(const e of verbEndings) if(s.endsWith(e)) return 'verb';
  }
  return 'noun';
}

function improvedParseText(text){
  text = (text||'').replace(/^\uFEFF/,'');
  const rawLines = text.split(/\r?\n/);
  const parsed = [];
  const skipped = [];
  for(let i=0;i<rawLines.length;i++){
    const raw = rawLines[i];
    const line = normalizeLine(raw);
    if(!line) continue;
    const sep = line.indexOf('-');
    if(sep === -1){
      skipped.push({index:i+1, raw:line});
      continue;
    }
    const left = line.slice(0, sep).trim();
    const right = line.slice(sep+1).trim();
    const rusVars = left ? left.split(',').map(s=>s.trim()).filter(Boolean) : [''];
    const arabicFull = right;
    parsed.push({ rawLine: line, arabicFull, rusVariants: rusVars, pos: detectPOS(rusVars) });
  }
  return { parsed, skipped };
}

/* ========== robust fetch ========== */
async function robustFetchWords(){
  // ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–µ–∑–æ–ø–∞—Å–Ω—É—é –∑–∞–≥—Ä—É–∑–∫—É —Å retry
  return await safeLoadWordsFile('words.txt', 3);
}

/* ========== ‚úÖ Save/Load State (–ü–û–î–ö–û–õ–õ–ï–ö–¶–ò–Ø) ========== */
async function saveState(){
  let st = null;
  try {
    st = {
      trainerId: TRAINER_ID,
      code: USER_CODE,
      allRaw: allWords.map(w => w.rawLine),
      orderRaw: orderRaw.slice(),
      currentRaw,
      mistakesRaw: mistakes.slice(),
      correctsRaw: corrects.slice(),
      mode,
      direction,
      timestamp: Date.now()
    };
    
    // ‚úÖ –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ Firebase (–ø–æ–¥–∫–æ–ª–ª–µ–∫—Ü–∏—è) + backup –≤ localStorage
    if (window.firebaseEnabled && window.firestore && window.firebaseModules && st) {
      await safeFirebaseSave(
        async () => {
          const docRef = window.firebaseModules.doc(
            window.firestore, 
            'users', USER_CODE, 
            'trainers', TRAINER_ID
          );
          return await window.firebaseModules.setDoc(docRef, st, { merge: true });
        },
        PREFIX + 'state',
        st
      );
      console.log('‚úì –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ Firestore (choice)');
    } else {
      // Fallback: —Ç–æ–ª—å–∫–æ localStorage
      safeLocalStorageSet(PREFIX + 'state', st);
    }
  } catch(e) {
    console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å:', e);
  }
}

async function loadState(){
  // ‚úÖ –ó–∞–≥—Ä—É–∂–∞–µ–º —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º safeFirebaseLoad (Firebase + fallback localStorage)
  if(window.firebaseEnabled && window.firestore && window.firebaseModules){
    const data = await safeFirebaseLoad(
      async () => {
        const docRef = window.firebaseModules.doc(
          window.firestore, 
          'users', USER_CODE, 
          'trainers', TRAINER_ID
        );
        const docSnap = await window.firebaseModules.getDoc(docRef);
        if(docSnap.exists()){
          console.log('‚úì –ó–∞–≥—Ä—É–∂–µ–Ω–æ –∏–∑ Firestore (choice)');
          return docSnap.data();
        }
        return null;
      },
      PREFIX + 'state'
    );
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ timestamp (–º–∞–∫—Å 30 –¥–Ω–µ–π)
    if(data && data.timestamp && (Date.now() - data.timestamp) < 30*24*60*60*1000){
      return data;
    }
  }
  
  // Fallback: —Ç–æ–ª—å–∫–æ localStorage
  return safeLocalStorageGet(PREFIX + 'state', 30*24*60);
}

function parseSingleLineToObj(line){
  const { parsed } = improvedParseText(line);
  return parsed && parsed[0] ? parsed[0] : null;
}

/* ========== Restore logic ========== */
async function restoreStateAfterLoad(serverWords){
  const st = await loadState();
  if(!st || !st.allRaw || st.allRaw.length === 0) return false;
  
  const oldAllWords = (st.allRaw || []).map(raw => parseSingleLineToObj(raw) || {rawLine: raw});
  const serverRawSet = new Set(serverWords.map(w => w.rawLine));
  const removedOldRaws = [];
  
  allWords = [];
  oldAllWords.forEach(oldWord => {
    if (serverRawSet.has(oldWord.rawLine)) {
      allWords.push(oldWord);
    } else {
      removedOldRaws.push(oldWord.rawLine);
    }
  });
  
  orderRaw = (st.orderRaw || []).filter(r => serverRawSet.has(r));
  mistakes = (st.mistakesRaw || []).filter(r => serverRawSet.has(r));
  corrects = (st.correctsRaw || []).filter(r => serverRawSet.has(r));
  currentRaw = (st.currentRaw && serverRawSet.has(st.currentRaw)) ? st.currentRaw : null;
  mode = st.mode || 'all';
  direction = st.direction || 'arab-to-rus';
  
  const serverByStripped = new Map();
  serverWords.forEach(w => {
    const stripped = stripHarakat(w.arabicFull || '');
    if (stripped) serverByStripped.set(stripped, w);
  });
  
  removedOldRaws.forEach(oldRaw => {
    const oldObj = parseSingleLineToObj(oldRaw);
    if (!oldObj) return;
    const oldStripped = stripHarakat(oldObj.arabicFull || '');
    if (!oldStripped) return;
    const candidate = serverByStripped.get(oldStripped);
    if (candidate) {
      if (!allWords.some(w => w.rawLine === candidate.rawLine)) {
        allWords.push(candidate);
      }
      orderRaw = orderRaw.map(r => r === oldRaw ? candidate.rawLine : r);
      mistakes = mistakes.map(r => r === oldRaw ? candidate.rawLine : r);
      corrects = corrects.map(r => r === oldRaw ? candidate.rawLine : r);
      if (currentRaw === oldRaw) currentRaw = candidate.rawLine;
      mistakes = mistakes.filter(r => r !== candidate.rawLine);
      corrects = corrects.filter(r => r !== candidate.rawLine);
      if (!orderRaw.includes(candidate.rawLine)) {
        orderRaw.unshift(candidate.rawLine);
      }
      serverByStripped.delete(oldStripped);
    }
  });
  
  const serverByRaw = new Map(serverWords.map(w => [w.rawLine, w]));
  const changedWords = [];
  allWords.forEach((existing, index) => {
    const serverWord = serverByRaw.get(existing.rawLine);
    if (serverWord && getWordContentHash(existing) !== getWordContentHash(serverWord)) {
      allWords[index] = serverWord;
      changedWords.push(serverWord.rawLine);
    }
  });
  
  changedWords.forEach(raw => {
    mistakes = mistakes.filter(r => r !== raw);
    corrects = corrects.filter(r => r !== raw);
    if (!orderRaw.includes(raw)) {
      orderRaw.unshift(raw);
    }
  });
  
  return true;
}

/* ========== Helpers ========== */
function updateProgress(){
  const total = allWords.length;
  const done = total - orderRaw.length;
  progressDiv.textContent = `${done}/${total} —Å–ª–æ–≤ –ø—Ä–æ–π–¥–µ–Ω–æ ‚Äì ${mistakes.length} –æ—à–∏–±–æ–∫`;
}

function renderLists(){
  correctListDiv.innerHTML = corrects.length ? corrects.map(c=>`<div>${escapeHtml(c)}</div>`).join('') : '‚Äî';
  mistakeListDiv.innerHTML = mistakes.length ? mistakes.map(c=>`<div>${escapeHtml(c)}</div>`).join('') : '‚Äî';
}

/* ========== Order & showing ========== */
function prepareOrder(source='all'){
  if(source === 'all'){
    orderRaw = allWords.map(w=>w.rawLine);
    shuffle(orderRaw);
    mode = 'all';
  } else {
    orderRaw = mistakes.slice();
    shuffle(orderRaw);
    mode = 'mistakes';
  }
  saveState();
}

function displayCurrentRaw(){
  if(!currentRaw){
    nextWord();
    return;
  }
  const obj = allWords.find(w=>w.rawLine===currentRaw) || parseSingleLineToObj(currentRaw);
  
  if(direction === 'arab-to-rus'){
    let displayArabic = (obj && obj.arabicFull) ? obj.arabicFull : (currentRaw || '');
    displayArabic = displayArabic.replace(/\s*-\s*/g,' - ').trim();
    arabicWordDiv.textContent = displayArabic || '[–Ω–µ—Ç –∞—Ä–∞–±—Å–∫–æ–≥–æ]';
    arabicWordDiv.setAttribute('dir','rtl');
    arabicWordDiv.classList.remove('rus-mode');
    
    const correctText = (obj && obj.rusVariants) ? obj.rusVariants.join(', ') : '(–Ω–µ—Ç –ø–µ—Ä–µ–≤–æ–¥–∞)';
    const distractors = findDistractorsFor(obj||{pos:'noun', rawLine:currentRaw}, 2);
    const options = [correctText, (distractors[0]?.rusVariants||[]).join(', ') || '‚Äî', (distractors[1]?.rusVariants||[]).join(', ') || '‚Äî'];
    shuffle(options);
    
    optButtons.forEach((btn,idx) => {
      btn.textContent = options[idx] || '';
      btn.disabled = false;
      btn.classList.remove('correct','wrong','arab-option');
      btn.dataset.correct = (options[idx] === correctText) ? '1' : '0';
    });
  } else {
    const displayRussian = (obj && obj.rusVariants) ? obj.rusVariants.join(', ') : '(–Ω–µ—Ç –ø–µ—Ä–µ–≤–æ–¥–∞)';
    arabicWordDiv.textContent = displayRussian;
    arabicWordDiv.setAttribute('dir','ltr');
    arabicWordDiv.classList.add('rus-mode');
    
    const correctText = (obj && obj.arabicFull) ? obj.arabicFull : '';
    const distractors = findDistractorsFor(obj||{pos:'noun', rawLine:currentRaw}, 2);
    const options = [correctText, distractors[0]?.arabicFull || '‚Äî', distractors[1]?.arabicFull || '‚Äî'];
    shuffle(options);
    
    optButtons.forEach((btn,idx) => {
      btn.textContent = options[idx] || '';
      btn.disabled = false;
      btn.classList.remove('correct','wrong');
      btn.classList.add('arab-option');
      btn.dataset.correct = (options[idx] === correctText) ? '1' : '0';
    });
  }
  
  updateProgress();
  renderLists();
}

function nextWord(){
  if(!orderRaw || orderRaw.length === 0){
    finishSession();
    return;
  }
  
  const raw = orderRaw.shift();
  currentRaw = raw;
  saveState();
  
  const obj = allWords.find(w=>w.rawLine===raw) || parseSingleLineToObj(raw) || { rawLine:raw, arabicFull:raw, rusVariants:[''] };
  
  if(direction === 'arab-to-rus'){
    let displayArabic = (obj.arabicFull || '').trim();
    if(!displayArabic){
      const sep = raw.indexOf('-');
      if(sep !== -1) displayArabic = raw.slice(sep+1).trim();
    }
    displayArabic = displayArabic.replace(/\s*-\s*/g,' - ').trim();
    arabicWordDiv.textContent = displayArabic || '[–Ω–µ—Ç –∞—Ä–∞–±—Å–∫–æ–≥–æ]';
    arabicWordDiv.setAttribute('dir','rtl');
    arabicWordDiv.classList.remove('rus-mode');
    
    const correctText = (obj.rusVariants||[]).join(', ') || '(–Ω–µ—Ç –ø–µ—Ä–µ–≤–æ–¥–∞)';
    const distractors = findDistractorsFor(obj, 2);
    const options = [correctText, (distractors[0]?.rusVariants||[]).join(', ') || '‚Äî', (distractors[1]?.rusVariants||[]).join(', ') || '‚Äî'];
    shuffle(options);
    
    optButtons.forEach((btn,idx) => {
      btn.textContent = options[idx] || '';
      btn.disabled = false;
      btn.classList.remove('correct','wrong','arab-option');
      btn.dataset.correct = (options[idx] === correctText) ? '1' : '0';
    });
  } else {
    const displayRussian = (obj.rusVariants||[]).join(', ') || '(–Ω–µ—Ç –ø–µ—Ä–µ–≤–æ–¥–∞)';
    arabicWordDiv.textContent = displayRussian;
    arabicWordDiv.setAttribute('dir','ltr');
    arabicWordDiv.classList.add('rus-mode');
    
    const correctText = obj.arabicFull || '';
    const distractors = findDistractorsFor(obj, 2);
    const options = [correctText, distractors[0]?.arabicFull || '‚Äî', distractors[1]?.arabicFull || '‚Äî'];
    shuffle(options);
    
    optButtons.forEach((btn,idx) => {
      btn.textContent = options[idx] || '';
      btn.disabled = false;
      btn.classList.remove('correct','wrong');
      btn.classList.add('arab-option');
      btn.dataset.correct = (options[idx] === correctText) ? '1' : '0';
    });
  }
  
  updateProgress();
  renderLists();
}

function findDistractorsFor(correctObj, count){
  if(direction === 'arab-to-rus'){
    const same = allWords.filter(w => w.pos === (correctObj&&correctObj.pos) && w.rawLine !== (correctObj&&correctObj.rawLine));
    shuffle(same);
    const picks = same.slice(0,count);
    if(picks.length < count){
      const others = allWords.filter(w => w.rawLine !== (correctObj&&correctObj.rawLine) && !picks.includes(w));
      shuffle(others);
      for(const o of others){ if(picks.length>=count) break; picks.push(o); }
    }
    while(picks.length < count) picks.push(correctObj||{rusVariants:['']});
    return picks.slice(0,count);
  } else {
    const correctRus = (correctObj?.rusVariants||[]).join(',').toLowerCase();
    const candidates = allWords.filter(w => {
      if(w.rawLine === (correctObj&&correctObj.rawLine)) return false;
      const wRus = (w.rusVariants||[]).join(',').toLowerCase();
      return wRus !== correctRus;
    });
    
    const samePos = candidates.filter(w => w.pos === (correctObj&&correctObj.pos));
    shuffle(samePos);
    const picks = samePos.slice(0,count);
    
    if(picks.length < count){
      const others = candidates.filter(w => !picks.includes(w));
      shuffle(others);
      for(const o of others){ if(picks.length>=count) break; picks.push(o); }
    }
    
    while(picks.length < count) picks.push({arabicFull:'‚Äî', rusVariants:[''], pos:'noun'});
    return picks.slice(0,count);
  }
}

/* ========== –ü–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å —Ñ–æ—Ä–º–∞—Ç–∞ ========== */
formatToggle.addEventListener('click', ()=>{
  if(direction === 'arab-to-rus'){
    direction = 'rus-to-arab';
    formatToggle.classList.add('active');
  } else {
    direction = 'arab-to-rus';
    formatToggle.classList.remove('active');
  }
  saveState();
  if(currentRaw){
    displayCurrentRaw();
  }
});

/* ========== –í–∞—Ä–∏–∞–Ω—Ç—ã (–∫–Ω–æ–ø–∫–∏) ========== */
optButtons.forEach(btn=>{
  btn.addEventListener('click', (e)=>{
    const chosen = e.currentTarget;
    const isCorrect = chosen.dataset.correct === '1';
    optButtons.forEach(b=>b.disabled=true);
    
    const curRaw = currentRaw;
    const obj = allWords.find(w=>w.rawLine===curRaw) || parseSingleLineToObj(curRaw) || { rawLine:curRaw, arabicFull:curRaw, rusVariants:[''] };
    
    if(isCorrect){
      chosen.classList.add('correct');
      if(!corrects.includes(obj.rawLine)) corrects.push(obj.rawLine);
      renderLists(); 
      saveState();
      setTimeout(()=>{ 
        currentRaw=null; 
        if(orderRaw.length===0) finishSession(); 
        else nextWord(); 
      }, 450);
    } else {
      chosen.classList.add('wrong');
      if(!mistakes.includes(obj.rawLine)) mistakes.push(obj.rawLine);
      renderLists(); 
      saveState();
      
      const wrongQuestion = direction === 'arab-to-rus' ? obj.arabicFull : (obj.rusVariants||[]).join(', ');
      const wrongAnswer = direction === 'arab-to-rus' ? (obj.rusVariants||[]).join(', ') : obj.arabicFull;
      
      showWrongModal(wrongQuestion, wrongAnswer, ()=>{ 
        currentRaw=null; 
        if(orderRaw.length===0) finishSession(); 
        else nextWord(); 
      });
    }
  });
});

/* ========== –ú–æ–¥–∞–ª–∫–∞ 17—Å ========== */
let modalTimer = null;
function showWrongModal(questionText, answerText, onClose){
  closeModal();
  const overlay = document.createElement('div'); 
  overlay.className='overlay';
  const modal = document.createElement('div'); 
  modal.className='modal';
  modal.innerHTML = `<h2>–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ</h2><div class="label">–í–æ–ø—Ä–æ—Å –±—ã–ª:</div><div class="answer">${escapeHtml(questionText)}</div><div class="label" style="margin-top:12px">–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç:</div><div class="answer">${escapeHtml(answerText)}</div><div style="text-align:right;margin-top:12px"><button id="modal-close-btn" class="button">–ó–∞–∫—Ä—ã—Ç—å (Esc)</button></div>`;
  overlay.appendChild(modal); 
  modalRoot.appendChild(overlay);
  
  function cleanup(){ 
    if(modalTimer){ clearTimeout(modalTimer); modalTimer=null; } 
    document.removeEventListener('keydown', onKey); 
    const b=document.getElementById('modal-close-btn'); 
    if(b) b.removeEventListener('click', onBtn); 
    if(overlay.parentNode) overlay.parentNode.removeChild(overlay); 
  }
  function onKey(e){ if(e.key==='Escape'){ cleanup(); if(typeof onClose==='function') onClose(); } }
  function onBtn(){ cleanup(); if(typeof onClose==='function') onClose(); }
  
  document.addEventListener('keydown', onKey);
  const btn = document.getElementById('modal-close-btn'); 
  if(btn) btn.addEventListener('click', onBtn);
  modalTimer = setTimeout(()=>{ cleanup(); if(typeof onClose==='function') onClose(); }, AUTO_MODAL_CLOSE_MS);
}

function closeModal(){ 
  modalRoot.innerHTML=''; 
  if(modalTimer){ clearTimeout(modalTimer); modalTimer=null; } 
}

/* ========== ‚úÖ –ú–æ–¥–∞–ª –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Å–±—Ä–æ—Å–∞ (–ü–û–î–ö–û–õ–õ–ï–ö–¶–ò–Ø) ========== */
async function showResetModal() {
  closeModal();
  const overlay = document.createElement('div'); 
  overlay.className = 'overlay';
  const modal = document.createElement('div'); 
  modal.className = 'modal';
  modal.innerHTML = `
    <div><strong>–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Å–±—Ä–æ—Å–∞</strong></div>
    <div style="margin-top:12px">–í—ã —É–≤–µ—Ä–µ–Ω—ã? –í—Å–µ –≤—ã—É—á–µ–Ω–Ω—ã–µ —Å–ª–æ–≤–∞ –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å –±—É–¥—É—Ç –ø–æ—Ç–µ—Ä—è–Ω—ã. –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å.</div>
    <div style="text-align:right;margin-top:16px">
      <button id="modal-cancel" class="button" style="margin-right:8px">–û—Ç–º–µ–Ω–∞</button>
      <button id="modal-confirm" class="button" style="background:#fff0f0;border-color:#f0b6b6">–î–∞, —Å–±—Ä–æ—Å–∏—Ç—å</button>
    </div>
  `;
  overlay.appendChild(modal);
  modalRoot.appendChild(overlay);
  
  function cleanup() {
    document.removeEventListener('keydown', onKey);
    overlay.removeEventListener('click', onOverlay);
    const cancelBtn = document.getElementById('modal-cancel');
    const confirmBtn = document.getElementById('modal-confirm');
    if (cancelBtn) cancelBtn.removeEventListener('click', onCancel);
    if (confirmBtn) confirmBtn.removeEventListener('click', onConfirm);
    if(overlay.parentNode) overlay.parentNode.removeChild(overlay);
  }
  
  function onKey(e) { if (e.key === 'Escape') onCancel(); }
  function onOverlay(e) { if (e.target === overlay) onCancel(); }
  function onCancel() { cleanup(); }
  
  async function onConfirm() {
    cleanup();
    
    // ‚úÖ –£–¥–∞–ª—è–µ–º –∏–∑ localStorage
    try{ 
      localStorage.removeItem(PREFIX + 'state'); 
      localStorage.removeItem(PREFIX + 'state_backup'); 
      // –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö backup'–æ–≤
      cleanOldBackups(0);
    }catch(e){}
    
    // ‚úÖ –£–¥–∞–ª—è–µ–º –∏–∑ Firebase (–ø–æ–¥–∫–æ–ª–ª–µ–∫—Ü–∏—è) —Å retry
    if(window.firebaseEnabled && window.firestore && window.firebaseModules){
      await safeFirebaseOperation(
        async () => {
          const docRef = window.firebaseModules.doc(
            window.firestore, 
            'users', USER_CODE, 
            'trainers', TRAINER_ID
          );
          await window.firebaseModules.deleteDoc(docRef);
          console.log('‚úì –£–¥–∞–ª–µ–Ω–æ –∏–∑ Firestore (choice)');
        },
        '–£–¥–∞–ª–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ (choice)',
        2
      );
    }
    
    orderRaw = allWords.map(w=>w.rawLine);
    shuffle(orderRaw);
    currentRaw = null;
    mistakes = [];
    corrects = [];
    mode = 'all';
    direction = 'arab-to-rus';
    formatToggle.classList.remove('active');
    
    correctListDiv.innerHTML = '‚Äî';
    mistakeListDiv.innerHTML = '‚Äî';
    afterDiv.classList.add('hidden');
    nextWord();
  }
  
  document.addEventListener('keydown', onKey);
  overlay.addEventListener('click', onOverlay);
  document.getElementById('modal-cancel').addEventListener('click', onCancel);
  document.getElementById('modal-confirm').addEventListener('click', onConfirm);
}

/* ========== –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ / —Å–ø–∏—Å–∫–∏ ========== */
function finishSession(){
  const total = allWords.length || 0;
  const done = total - (orderRaw.length || 0);
  arabicWordDiv.textContent = `–ì–æ—Ç–æ–≤–æ! –ü—Ä–æ–π–¥–µ–Ω–æ ${done}/${total}, –æ—à–∏–±–æ–∫: ${mistakes.length}`;
  arabicWordDiv.classList.remove('rus-mode');
  afterDiv.classList.remove('hidden');
  workMistakesBtn.classList.toggle('hidden', mistakes.length === 0);
  saveState(); 
  renderLists();
}

/* ========== –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö —Å–ª–æ–≤ ========== */
async function addNewWords(){
  try{
    const txt = await robustFetchWords();
    const { parsed } = improvedParseText(txt);
    if(!Array.isArray(parsed)) return alert('–ù–µ—Ç –ø–∞—Ä—Å–∏—Ä—É–µ–º—ã—Ö —Å—Ç—Ä–æ–∫ –≤ words.txt');
    
    const existingSet = new Set(allWords.map(w=>w.rawLine));
    let added = 0;
    
    for(const p of parsed){
      if(!existingSet.has(p.rawLine)){
        allWords.push(p);
        const pos = Math.floor(Math.random() * (orderRaw.length + 1));
        orderRaw.splice(pos, 0, p.rawLine);
        added++;
        existingSet.add(p.rawLine);
      }
    }
    
    if(added === 0){
      alert('–ù–æ–≤—ã—Ö —Å–ª–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.');
    } else {
      await saveState();
      updateProgress();
      alert('–î–æ–±–∞–≤–ª–µ–Ω–æ –Ω–æ–≤—ã—Ö —Å–ª–æ–≤: ' + added);
      
      if (added > 0 && orderRaw.length > 0) {
        afterDiv.classList.add('hidden');
        if (!currentRaw) {
          nextWord();
        } else {
          displayCurrentRaw();
        }
      }
    }
  }catch(e){
    console.error(e);
    alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Å–ª–æ–≤.');
  }
}

/* ========== –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫ ========== */
function copyMistakes(){
  if(!mistakes.length) return alert('–û—à–∏–±–æ–∫ –Ω–µ—Ç.');
  const text = mistakes.join('\n');
  navigator.clipboard.writeText(text).then(()=> alert('–û—à–∏–±–∫–∏ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω—ã')).catch(()=> alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å'));
}

/* ========== –ó–∞–≥—Ä—É–∑–∫–∞ –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ========== */
async function loadWords() {
  if(loadingPromise) return loadingPromise;
  
  loadingPromise = (async () => {
    try {
      const txt = await robustFetchWords();
      const { parsed, skipped } = improvedParseText(txt);
      const serverWords = parsed.slice();
      
      const restored = await restoreStateAfterLoad(serverWords);
      
      if (!restored || allWords.length === 0) {
        allWords = serverWords.slice();
        orderRaw = allWords.map(w=>w.rawLine); 
        shuffle(orderRaw);
        mistakes = []; 
        corrects = []; 
        currentRaw = null; 
        mode = 'all';
        direction = 'arab-to-rus';
        await saveState();
      }
      
      if(skipped && skipped.length) {
        console.warn('–ù–µ–∫–æ—Ç–æ—Ä—ã–µ —Å—Ç—Ä–æ–∫–∏ –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω—ã (–Ω–µ—Ç –¥–µ—Ñ–∏—Å–∞):', skipped.slice(0,20));
      }
      
      console.log('–°–ª–æ–≤–∞—Ä—å –∑–∞–≥—Ä—É–∂–µ–Ω:', allWords.length, '—Å–ª–æ–≤');
      return true;
    } catch(err) {
      console.error('–ó–∞–≥—Ä—É–∑–∫–∞ words.txt –Ω–µ —É–¥–∞–ª–∞—Å—å:', err);
      return false;
    }
  })();
  
  return loadingPromise;
}

/* ========== –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ UI ========== */
addNewBtn.addEventListener('click', addNewWords);
resetProgressBtn.addEventListener('click', showResetModal);
copyMistakesBtn.addEventListener('click', copyMistakes);

retryAllBtn.addEventListener('click', ()=> {
  prepareOrder('all');
  currentRaw = null; 
  mistakes=[]; 
  corrects=[];
  afterDiv.classList.add('hidden');
  saveState();
  nextWord();
});

workMistakesBtn.addEventListener('click', ()=> {
  if(!mistakes.length) return alert('–û—à–∏–±–æ–∫ –Ω–µ—Ç.');
  prepareOrder('mistakes');
  afterDiv.classList.add('hidden');
  saveState();
  nextWord();
});

/* ========== –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ========== */
(async function init(){
  try{
    await loadWords();
    
    if(direction === 'rus-to-arab'){
      formatToggle.classList.add('active');
    } else {
      formatToggle.classList.remove('active');
    }
    
    if(currentRaw){
      displayCurrentRaw();
    } else {
      nextWord();
    }
  }catch(e){
    console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏:', e);
    arabicWordDiv.textContent = '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–ª–æ–≤–∞—Ä—è';
  }
})();

window.addEventListener('beforeunload', () => { 
  saveState().catch(e => console.warn('Save on unload failed:', e)); 
});

window.addEventListener('visibilitychange', ()=>{ 
  if(document.visibilityState==='hidden') {
    saveState().catch(e => console.warn('Save on visibility change failed:', e)); 
  }
});
</script>
</body>
</html>
